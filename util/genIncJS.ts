//!/usr/bin/env python

// Copyright 2017 Yoav Seginer, Theo Vosse, Gil Harari, and Uri Kolodny.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// this script is used to create an application file from a cdl script,
// resolving references to other files to their actual paths.
//
// it is used in two different stages:
//
//  1. creating a compilation program, a program that would compile the
//     cdl code into a feg program
//     the generated program includes the cdl-source along with all the
//     class-files it may refer to, as well as the compilation code
//
//  2. creating the runtime program, that implements the application
//     the generated program includes the compiled feg, as well as the cdl
//     runtime environment interpreting it
//
// Both of these could use this script in either of its two modes:
//
//  1. 'js' mode - generates a single javascript file, into which all the
//         javascript files are concatenated
//
//  2. 'html' mode - generate am html file referencing the javascript file
//         with html '<script>' tags
//
//  3. 'incl' mode - generates a list of included files
//
//  4. 'make' mode - generates a make file dependency
//
// Notes:
//  Compilation stage normally generates a 'js' file, which is then run in
//   'node.js'.
//  However, when debugging the compiler it is convenient to generate an 'html'
//   version of the compilation program, and execute it in a browser, with its
//   superior debugging environment
//
// 'html' mode is used in the development environment for runtime programs,
//   so that the browser's debugger provides easy access to the run-time
//   javascript files. Changes to the run-time javascript files take affect
//   with but a reload of the browser, while changes to typescript files require
//   compiling typescript to javascript (but not cdl recompilation or
//   re-generation of the .html file by this script).
//   For batch automatic test execution, node.js is used, so 'js' mode is
//    required.
//   Also, the 'production' format, as uploaded to the build-web-site, uses
//    an 'uglified' single-file javascript referenced by an html file. This
//    single-file javascript is generated by this script using 'js' mode.
//
//
//
// Basic Functionality:
//
// This script takes two main input files: a template file and a source file.
// The template file guides the generation of the output file. For 'simple'
//  template lines, the script merely copies the line from the template file to
//  the output file.
//  However, the template files typically also uses directives and macros.
//  Directives affect an inclusion of another file. In 'html' mode, this is
//   achieved by placing a <script> tag in the output file, while in 'js' mode
//   the actual content of the included file is written to the output file.
//   In either modes, included files are recursively processed, so that nested
//   inclusion directives are handled.
//  Macros are replaced by a string which this script computes. For example,
//   the title macro, '%%title:()%%', is replaced with the value of the '--title'
//   argument to this script.
//
// confLib handling:
//
// When generating a compilation program, this script can be given the
//  path of the a --libconf' file. A libconf file describes a hierarchy of
//  conf-libs, where each conf-lib is described in a single line by its name
//  and path, separated by a colon, e.g. 'Core:../../core'
//
// In a libconf file is specified, the behavior of this script is modified in
//  the following ways:
//
// - the script translates an instance of 'var classes = ' in a file 'fn.js'
//   of confLib 'CL' to 'var CL__fn__classes ='
//   if the classes are already defined with a variable which is the basename
//   of the file, that case is recognized too:
//     'var fn =' in fn.js is converted to 'var CL__fn ='
//
// - the script emits a list with the class-lists and their confLib,
//  { confLib: "CL1", classes: [CL1__fn1_1__classes, CL1__fn1_2__classes, ...] },
//  { confLib: "CL2", classes: CL2__fn2_1__classes, ...] }, ...
//
// - the scripts recognizes a macro '%%conflibPreamble:()%%', and replaces it
//     with the inclusion of a file with a fixed name for each conf-lib in the
//     libconf file. Given a conflib path <clpath1>, the script includes the
//     file "<clpath1>/includeList.js".
//
//
// command line arguments:
//
// -o/--out_file - the output file, into which the generated .js/.html file is
//      written
//
// -t/--template - the 'template' input file, the file controlling the output
//      file format
//
// -m/--mode - js/html
//
// --includedir - add the argument to the list of directories in which include
//      files (encountered in %%include%%: macros) are searched for
//
// --langdir - set the argument as the root directory for scripts. it is added
//      to all search paths (include/classfile/image/constantfile/textfile/url)
//
// --cdldir -- like langdir, but for cdl
//
// -c/--libConf - the argument is a libConf file, detailing a hierarchy of
//      confLibs and their paths
//
// --buildInfoFile - the argument is the buildInfo file, which would become the
//      value of the %%buildinfo:()%% macro. This file typically defines the
//      version control revision, time stamp, etc
//
// --commonImageDir - when specified, images encountered in %%image:()%% macros
//      are not resolved as usual, to the first directory in the image path
//      containing the named image file. Rather, all image macros are resolved
//      to the specified commonImageDir. This is used when generating the
//      production environment, where all images are collated to a single dir
//
// --commonDataDir - like commonImageDir, but for %data:()%%
//
// --title - the argument would become the value of the %%title:()%% macro
//
// --max-include-level - do not process include lines above this level
//
// --referencedir - sets the reference directory for file name normalization
//
// --sourcedir - sets the directory that should be used for relative includes
//               from the source file; by default the directory of the source
//
// --splash-screen-url - the path to the HTML file which provides the splash
//                       screen. If not specified, the default is used.

import * as os from "./pyth2jscompat/os";
import * as sys from "./pyth2jscompat/sys";
import * as fs from "fs";
import * as misc from "./pyth2jscompat/misc";
import * as parseargs from "./pyth2jscompat/parseargs";
import * as cdlsyntax from "./cdl";

// global variables

// js/html
let mode: string|undefined = undefined;

// --title --> %%title:()%%
let title: string = "";

// --splash-screen-url
let splash_screen_url: string = "";

// don't include files higher than given level
let max_include_level: number = 999999999;

// --commonImageDir
let common_image_dir: string|undefined = undefined;

// --commonDataDir
let common_data_dir: string|undefined = undefined;

// all normalized paths are relative to this directory
// (absolute paths generated in a cygwin environment are meaningless to the
// non-cygwin browser reading these paths, so paths are created as relative)
let reference_dir: string|undefined = undefined;

// When not none, this is supposed to be the base directory relative to the
// source file; useful for ignoring the intermediate/ prefix when processing
// .run.js files.
let source_dir: string|undefined = undefined;

// a list of '{ name: cl-name, path: cl-path }' generated by parsing the
//  confLib file
//
let conf_lib_list: { name: string; path: string; }[] = [];

// for each file read/being-read, processed-files has an attribute which is the
//  file's name, and whose value is the line# we've reached within that file
let processed_files: {[path: string]: number} = {};

// the name of the file from which the last input line was read
//  has different value for each dtype (classfile/include/constantfile etc)
let last_file_name: Map<string, string> = new Map<string, string>();

// writing into this handle writes into the output file
let out_file_name: string;
let out_file_handle: number;

// handle to the file with the dependencies
let dep_file_name: string|undefined = undefined;
let dep_file_handle: number|undefined = undefined;

// search path per dtype - a list of directories
interface PathPerDType {
    include: string[];
    classfile: string[];
    constantfile: string[];
    template: string[];
    image: string[];
    data: string[];
    foreign: string[];
    text: string[];
    url: string[];
}
type DTypeKey = keyof(PathPerDType);
let path_per_dtype: PathPerDType = {
    include: <string[]>[],
    classfile: <string[]>[],
    constantfile: <string[]>[],
    template: <string[]>[],
    image: <string[]>[],
    data: <string[]>[],
    foreign: <string[]>[],
    text: <string[]>[],
    url: <string[]>[]
};

// the 'source' file, the single positional run-time argument --> 'source'
let cdl_source: string|undefined = undefined;

// --buildInfoFile --> %%buildinfo:()%%
let build_info_file: string|undefined = undefined;

// the stack of files currently being read, which file included which file etc
//  to get us to read the current file (at the top of stack)
let fn_stack: string[] = [];

// inclusion_cycle_permitted, default to false
// section, defaults to 'infix' (can be  set to 'prefix'/'suffix')
// 'conf_lib' - include paths used while procesing that conf-lib
// 'sticky_conf_lib' - include paths added and remain there
interface DTypeProperty {
    html?: string;
    conf_lib?: string[];
    section?: SectionKey;
    inclusion_cycle_permitted?: boolean;
    sticky_conf_lib?: string[];
}
let dtype_property: {[P in DTypeKey]: DTypeProperty} = {
    include: {
        conf_lib: ['design', 'func', 'automated' ],
        html: 'script',
        inclusion_cycle_permitted: true
    },
    classfile: {
        conf_lib: ['design', 'func', 'automated' ],
        html: 'script'
    },
    constantfile: {
        section: 'prefix',
        conf_lib: ['design', 'func', 'automated' ],
        html: 'script'
    },
    template: {},
    image: {
        sticky_conf_lib: ['design/img']
    },
    data: {},
    foreign: {},
    text: {},
    url: {}
};

// generally, text is not written directly into the output; rather it is
//  'written' by appending it to the appropriate section.
// in practice, all dtypes write to 'infix' except for 'constantfile' which
// writes into 'prefix', so that constants are defined by the time the classes
// attempt to use them
interface SectionText {
    prefix: string[];
    infix: string[];
    postfix: string[];
}
type SectionKey = keyof(SectionText);
let section_text: SectionText = {
    prefix: [],
    infix: [],
    postfix: [],
};

// conf_libs are inserted into it at 0, so that the conf-lib that ends up being
//  last (== the conf-lib of least priority) is the first to be inserted
// each entry has the following attributes:
//  'name' - conf-lib-name
//  'class_list' - the list of class_lists associated with this conf_lib
//                (e.g. ['Core__draggableClasses', 'Core__snappabaleClasses',..])
//  'constant' - the list of constant defs associated with this conf_lib
//               (as {
//                      'name': 'positioningConstants',
//                      'element': 'Core__positioningConstants'
//                   } )
//
interface ConfLib {
    name: string|undefined;
    class_list: string[];
    constant: {name: string; element: string;}[];
};
let conf_lib_by_priority: ConfLib[] = [];

let current_conf_lib: { 'priority': number; 'name': string|undefined; 'path': string|undefined; }|undefined = undefined;

// Counter for number of screenArea declarations and var test lines
let nr_screen_area: number = 0;
let nr_test: number = 0;

// Target for make file include
let make_target: string|undefined = undefined;

function error_exit(msg: string): never {
    console.error(sys.argv[0] + ": " + msg);
    return sys.exit(1);
}

// Dictionary to check that no two file names get mapped onto the same class
// variable
let class_stem_names: Map<string, string> = new Map<string, string>();

// return the extension-less basename of path and make sure it's a legal JS identifier
function stemname(path: string, conf_lib_name: string|undefined): string {
    const basename = os.path.splitext(os.path.basename(path))[0];
    const class_identifier = basename.replace(/[^a-zA-Z0-9_]+/g, "_");

    if (conf_lib_name === undefined) {
        return class_identifier;
    }
    const conflib_class_identifier: string = conf_lib_name + "__" + class_identifier;
    if (class_stem_names.has(conflib_class_identifier) && class_stem_names.get(conflib_class_identifier) !== path) {
        error_exit(`files ${path} and ${class_stem_names.get(conflib_class_identifier)} map to the same variable name`);
    }
    class_stem_names.set(class_identifier, path);
    return class_identifier;
}

function annotate(msg: string): void {
    console.log(msg);
}

function set_reference_dir(rd: string|undefined): void {
    try {
        if (rd === undefined) {
            reference_dir = os.path.realpath(os.getcwd());
        } else {
            reference_dir = os.path.realpath(rd);
        }
    } catch (e) {
        return error_exit(e.toString());
    }
}

function set_source_dir(sd: string): void {
    if (sd !== undefined) {
        try {
            source_dir = os.path.realpath(sd);
        } catch (e) {
            return error_exit(e.toString());
        }
    }
}

function normalize_path(path: string): string {
    try {
        const real_path = os.path.realpath(path);
        return os.path.relpath(real_path, reference_dir);
    } catch (e) {
        return error_exit(e.toString());
    }
}

function push_include_file(dtype: DTypeKey, fn: string): void {
    if (!(dtype in dtype_property)) {
        error_exit("unknown type '" + dtype + "'");
    }
    if (!dtype_property[dtype].inclusion_cycle_permitted &&
          fn_stack.indexOf(fn) >= 0) {
        error_exit(`inclusion cycle for '${fn}'`);
    }
    fn_stack.push(fn);
}

function pop_include_file(dtype: DTypeKey, fn: string): void {
    const popped_file = fn_stack.pop();

    if (popped_file !== fn) {
        error_exit(`internal error: wrong file in pop (${fn} != ${popped_file})`);
    }
    if (fn_stack.length === 1) {
        write_str(get_output_str());
    }
}

function get_last_file_name(dtype: DTypeKey): string {
    if (last_file_name.has(dtype)) {
        return last_file_name.get(dtype)!;
    }
    return "";
}

function set_last_file_name(dtype: DTypeKey, fn: string): void {
    last_file_name.set(dtype, fn);
}

function append_root_path(path: string): void {
    if (path !== undefined) {
        const paths: string[] = path.split(";");
        path_per_dtype.include = path_per_dtype.include.concat(paths);
        path_per_dtype.classfile = path_per_dtype.classfile.concat(paths);
        path_per_dtype.constantfile = path_per_dtype.constantfile.concat(paths);
        path_per_dtype.image = path_per_dtype.image.concat(paths);
        path_per_dtype.data = path_per_dtype.data.concat(paths);
        path_per_dtype.foreign = path_per_dtype.foreign.concat(paths.map((path) => os.path.join(path, "external", "foreignInterface")));
        path_per_dtype.text = path_per_dtype.text.concat(paths);
        path_per_dtype.url = path_per_dtype.url.concat(paths);
    }
}

function set_include_path(path_list: string[]): void {
    if (path_list !== undefined) {
        path_per_dtype.include = path_per_dtype.include.concat(path_list);
    }
}

function set_build_info_file(path: string): void {
    if (path !== undefined) {
        build_info_file = path;
    }
}

// Creates a directory at path if it doesn't exist, or is not a directory
function mkdir_if_not_exists(path: string): void {
    if (!os.path.isdir(path)) {
        if (os.path.exists(path)) {
            os.remove(path);
        }
        os.makedirs(path);
    }
}

function set_common_image_dir(path: string): void {
    if (path !== undefined) {
        common_image_dir = path;
        mkdir_if_not_exists(path);
    }
}

function set_common_data_dir(path: string): void {
    if (path !== undefined) {
        common_data_dir = path;
        mkdir_if_not_exists(path);
    }
}

function set_cdl_source(fn: string): void {
    cdl_source = fn;
}

function get_cdl_source(): string|undefined {
    return cdl_source;
}
  
function set_mode(m: string): void {
    mode = m;
}

function set_out_file(fn: string): void {
    out_file_name = fn;
    try {
        out_file_handle = fs.openSync(fn, "w");
    } catch (e) {
        return error_exit(e.toString());
    }
}

function set_dep_file(fn: string): void {
    if (fn !== undefined) {
        dep_file_name = fn;
        try {
            dep_file_handle = fs.openSync(fn, "w");
        } catch (e) {
            return error_exit(e.toString());
        }
    }
}

// Name of the file that stores the resources used in the current input
let res_out_file_name: string|undefined = undefined;

// used resources per resource type
interface UsedResources {
    foreign: {[resourcePath: string]: boolean};
    font: {[resourcePath: string]: boolean};
    text: {[resourcePath: string]: boolean};
};
type ResourceKey = keyof(UsedResources);

let used_resources: UsedResources = {
    foreign: {},
    font: {},
    text: {}
};
// flag to indicate use of external resources
let does_use_resources = false;

function set_res_out_file(fn: string): void {
    res_out_file_name = fn;
}

function add_resource_usage(res_type: ResourceKey, res_uri: string): void {
    if (res_uri in used_resources[res_type]) {
        return;
    }
    used_resources[res_type][res_uri] = true;
    does_use_resources = true;
}

function write_resource_usage(): void {
    if (res_out_file_name !== undefined) {
        if (does_use_resources) {
            if (os.path.exists(res_out_file_name)) {
                const dict = JSON.parse(misc.readTextFile(res_out_file_name));
                if (misc.objectEqual(dict, used_resources)) {
                    return;
                }
            }
            fs.writeFileSync(res_out_file_name, JSON.stringify(used_resources));
        } else if (os.path.exists(res_out_file_name)) {
            os.remove(res_out_file_name);
        }
    }
}

function set_res_use_file(fn: string): void {
    if (fn !== undefined && os.path.exists(fn)) {
        used_resources = JSON.parse(misc.readTextFile(fn));
    }
}

function write_font_urls(directive_prefix: string): void {
    if (mode === 'html') {
        for (const url in used_resources.font) {
            write_str(directive_prefix + '<link rel="stylesheet" type="text/css" href="' + url + '">\n');
        }
    }
}

function set_title(str: string): void {
    title = str === undefined? "": str;
}

function set_splash_screen_url(str: string): void {
    splash_screen_url = str === undefined? "": str;
}
        
function set_make_target(arg: string, deflt: string): void {
    make_target = arg === undefined? deflt: arg;
}

function set_max_include_level(arg: string|undefined): void {
    if (arg !== undefined) {
        max_include_level = parseInt(arg);
    }
}

function write_str(str: string): void {
    fs.writeSync(out_file_handle, str);
}

function write_dep(fn: string): void {
    if (dep_file_handle !== undefined) {
        fs.writeSync(dep_file_handle, make_target + ': ' + fn + '\n');
    }
}

// called just before concatenating the sections (prefix/infix/postfix) into the
//  output file
// generates code to merge constants defined in several conf-lib constantfiles
//  into a single constant (assumes js mode)
function output_section_hook(): void {
    let constant_dict: {[name: string]: string[]} = {};

    for (const clentry of conf_lib_by_priority) {
        const cl_const_list = clentry.constant;
        for (const const_entry of cl_const_list) {
            const const_name = const_entry.name;
            const const_elem = const_entry.element;
            if (!(const_name in constant_dict)) {
                constant_dict[const_name] = [];
            }
            constant_dict[const_name].push(const_elem);
        }
        clentry.constant = [];
    }

    for (const const_name in constant_dict) {
        const const_merge_def: string =
            'var ' + const_name + ' = ' +  'mergeCdlConstants(\n\t[\n\t\t' +
            constant_dict[const_name].join(',\n\t\t') + '\n\t]\n)\n';
        section_print('constantfile', const_merge_def);
    }
}


function get_output_str(): string {
    output_section_hook();

    let str = section_text.prefix.join("");
    str += section_text.infix.join("");
    str += section_text.postfix.join("");

    section_text.prefix = [];
    section_text.infix = [];
    section_text.postfix = [];

    return str;
}

function section_print(dtype: DTypeKey, line: string): void {
    if (dtype === 'template') {
        write_str(line);
    } else {
        const section = dtype_property[dtype].section !== undefined?
                        dtype_property[dtype].section!: 'infix';
        section_text[section].push(line);
    }
}

// annotate js output file with the input fn/line#
function gen_filename_and_line_number(dtype: DTypeKey, fn: string): void {
    if (mode === 'html') {
        return;
    }
    if (get_last_file_name(dtype) !== fn) {
        if (mode === 'js') {
            section_print(dtype, "//# " + fn + ":" + String(processed_files[fn]) + '\n');
        }
        set_last_file_name(dtype, fn);
    }
    processed_files[fn] = processed_files[fn] + 1;
}

function find_file_in_path(dtype: string, basename: string): string {
    var path: string[] = [];

    if (basename.startsWith(".")) {
        if (os.path.isfile(basename)) {
            return basename;
        }
    } else if (dtype in path_per_dtype) {
        path = path_per_dtype[<DTypeKey>dtype];
        for (const dirp of path) {
            const file_path: string = os.path.join(dirp, basename);
            if (os.path.isfile(file_path)) {
                return file_path;
            }
        }
    }
    if (dtype === "image") {
        console.error("could not find path for image " + basename);
        return basename;
    }
    const path_list = path.join(":");
    return error_exit("could not find path for <" + dtype + "> file '" +
                      basename + "' in path '" + path_list + "'");
}

// add the conf-lib path for dtypes where this is required (e.g. classfile,
//  include)
function push_conf_lib_path(path: string): void {
    for (const dtype in dtype_property) {
        if (dtype_property[<DTypeKey>dtype].conf_lib !== undefined) {
            for (const sub_path of dtype_property[<DTypeKey>dtype].conf_lib!) {
                const dpath = os.path.join(path, sub_path);
                path_per_dtype[<DTypeKey>dtype].push(dpath);
            }
        }
    }
}

function pop_conf_lib_path(path: string): void {
    for (const dtype in dtype_property) {
        if (dtype_property[<DTypeKey>dtype].conf_lib !== undefined) {
            for (const sub_path of dtype_property[<DTypeKey>dtype].conf_lib!.slice().reverse()) {
                const dpath = os.path.join(path, sub_path);
                const apath = path_per_dtype[<DTypeKey>dtype].pop();
                if (apath !== dpath) {
                    error_exit("popped path does not match pushed path");
                }
            }
        }
    }
}

// add search path per the currently processed conf-lib, and leave it there so
//  that following files may use it too (also outside the current conf-lib)
//  for the appropriate dtypes (e.g. image, data)
function add_conf_lib_sticky_path(path: string): void {
    for (const dtype in dtype_property) {
        if (dtype_property[<DTypeKey>dtype].sticky_conf_lib !== undefined) {
            for (const sub_path of dtype_property[<DTypeKey>dtype].sticky_conf_lib!) {
                const dpath = os.path.join(path, sub_path);
                path_per_dtype[<DTypeKey>dtype].push(dpath);
            }
        }
    }
}

function add_conf_lib(priority: number, name: string|undefined, path: string|undefined): void {
    conf_lib_by_priority.unshift({
        name: name,
        class_list: [],
        constant: []
    });

    current_conf_lib = { 'priority': priority, 'name': name, 'path': path };

    if (name === undefined || path === undefined) {
        return;
    }

    push_conf_lib_path(path);
    const conf_lib_include = os.path.join(path, "includeList.js");
    if (os.path.exists(conf_lib_include)) {
        process_file('include', conf_lib_include, os.path.dirname(conf_lib_include));
    }
    pop_conf_lib_path(path);

    current_conf_lib = undefined;
}

            
function set_lib_conf(lib_conf: string): void {
    if (lib_conf === undefined || !os.path.exists(lib_conf)) {
        return;
    }
    const libConfLines: string[] = misc.readTextFileLines(lib_conf);
    for (const line of libConfLines) {
        // remove comments
        let match = line.match(/(([^;\/]|\/[^\/])*)((;|\/\/).*)?/);
        const nonComment = match![1];
        // skip empty lines
        if (/^\s*$/.test(nonComment)) {
            continue;
        }
        // parse (allowing spaces) <confLibName>:<confLibPath>
        match = nonComment.match(/^\s*([a-zA-Z0-9_]+)\s*:\s*([^\s]*)\s*$/);
        if (match === null || match[1] === "" || match[2] === "") {
            return error_exit("libConf file syntax error: '" + line + "'");
        }
        conf_lib_list.push({ 'name': match[1], 'path': match[2] });
    }
}

function gen_conf_lib_preamble(): string {
    for (const conf_lib of conf_lib_list) {
        add_conf_lib_sticky_path(conf_lib.path);
    }

    for (let idx = conf_lib_list.length - 1; idx >= 0; idx--) {
        const conf_lib = conf_lib_list[idx];
        const clpriority = conf_lib_list.length - idx;
        add_conf_lib(clpriority, conf_lib.name, conf_lib.path);
    }
    add_conf_lib(0, undefined, undefined);

    const preamble = get_output_str();
    return preamble;
}


function process_directive(line: string, directive_fn: string, linenr: number, basedir: string): void {
    let filename: string|undefined = undefined;
    let filenames: string[]|undefined = undefined;
    let relative_dir: string|undefined = undefined;

    const match = line.match(/^([^a-z]*)%%([a-z]+)%%:\s*(.*[^\s])\s*$/);
    if (match === null) {
        return error_exit(directive_fn + ':' + String(linenr) + ': directive has invalid syntax: ' + line);
    }
    const directive_prefix = match[1];
    const directive = match[2];
    if (!(directive in path_per_dtype)) {
        return error_exit(directive_fn + ':' + String(linenr) + ': unknown directive: ' + line);
    }
    const basename = match[3];

    const stdmatch = basename.match(/^<(.*)>$/);
    const quotematch = basename.match(/^"(.*)"$/);

    if (stdmatch !== null) {
        filename = find_file_in_path(directive, stdmatch[1]);
    } else if (quotematch !== null) {
        filename = os.path.join(basedir, quotematch[1]);
        if (!os.path.isfile(filename)) {
            filename = find_file_in_path(directive, quotematch[1]);
        }
    } else if (basename === 'source') {
        filename = get_cdl_source();
        if (source_dir !== undefined) {
            relative_dir = source_dir;
        }
    } else if (basename === 'foreign') {
        filenames = [];
        for (const fn in used_resources.foreign) {
            filenames.push(fn);
        }
    } else if (basename === 'fonturls') {
        write_font_urls(directive_prefix);
        return;
    } else {
        console.log('basename="' + basename + '"');
    }

    if (mode === 'incl') {
        console.log(directive, filename);
    }

    if (filename !== undefined) {
        if (relative_dir === undefined) {
            relative_dir = os.path.dirname(filename);
        }
        process_file(<DTypeKey>directive, filename, relative_dir);
    } else if (filenames !== undefined) {
        for (const filename of filenames) {
            process_file(<DTypeKey>directive, filename, os.path.dirname(filename));
        }
    } else {
        error_exit('invalid directive: ' + line);
    }
}

// Only compress svg images
function use_compression_for_image(filename: string): boolean {
    return filename.endsWith(".svg");
}

// Compress all data files
function use_compression_for_data(filename: string): boolean {
    return true;
}

// Stores which resource has been copied to which path; avoids duplicate copies
// and resolves faster
let copied_resources: {[hash: string]: string} = {};
// Stores which path is the target for which resource; avoids duplicate naming
let resource_targets: {[path: string]: string} = {};

function add_copied_resource(resource_hash: string, path: string): void {
    if (path in resource_targets && resource_targets[path] !== resource_hash) {
        error_exit(`${path} === the target for both ${resource_targets[path]} and ${resource_hash}`);
    }
    copied_resources[resource_hash] = path;
    resource_targets[path] = resource_hash;
}

// Returns the path to the file from the macro. When common_dir has been set,
// copies the file to that directory, compressing it when the extension allows
// it, but only when the source file is newer.
function copy_and_compress(type: string, macro_arg: string, use_compression_fun: (filename: string) => boolean, common_dir: string|undefined): string {
    const resource_hash: string = type + ':' + macro_arg;
    if (resource_hash in copied_resources) {
        return copied_resources[resource_hash];
    }
    const src_path = find_file_in_path(type, macro_arg);
    if (common_dir === undefined) {
        add_copied_resource(resource_hash, src_path);
        return src_path;
    }
    const out_path: string = os.path.join(common_dir, os.path.basename(macro_arg));
    if (!os.path.exists(src_path)) {
        console.error(`${type} does not exist: ${src_path}`);
        add_copied_resource(resource_hash, out_path);
        return out_path;
    }
    const use_compression: boolean = use_compression_fun(macro_arg);
    if (out_path === src_path) {
        add_copied_resource(resource_hash, src_path);
        return out_path; // In case someone puts the images in the common_dir
    }
    let target_path: string = out_path;
    if (use_compression) {
        target_path += '.gz';
    }
    if (!os.path.exists(target_path) || os.path.getmtime(target_path) < os.path.getmtime(src_path)) {
        if (use_compression) {
            misc.gzipFile(src_path, target_path);
        } else {
            fs.copyFileSync(src_path, target_path);
        }
    }
    add_copied_resource(resource_hash, src_path);
    return out_path;
}

// format: %%image:(url)%%. Behaves like process_image_macro.
// Calls copy_and_compress for an image
function process_image_macro(macro_name: string, macro_args: string[]): string {
    return copy_and_compress('image', macro_args[0], use_compression_for_image, common_image_dir);
}

// format: %%font:(fontFamily,url)%%, no comma in the font name, no superfluous spaces
function process_font_macro(macro_name: string, macro_args: string[]): string {
    if (macro_args.length < 2) {
        error_exit('font macro should have two arguments');
    }
    const url = macro_args.slice(1).join(","); // in case the URL constains commas
    add_resource_usage('font', url);
    return macro_args[0];
}

// format: %%data:(url)%%. Behaves like process_image_macro.
// Calls copy_and_compress for a data file
function process_data_macro(macro_name: string, macro_args: string[]): string {
    return copy_and_compress('data', macro_args[0], use_compression_for_data, common_data_dir);
}

function process_buildinfo_macro(macro_name: string, macro_args: string[]): string|undefined {
    return build_info_file;
}

function process_conf_lib_preamble_macro(macro_name: string, macro_args: string[]): string {
    push_include_file('template', '--conf-lib-include--');
    const str: string = '\n' + gen_conf_lib_preamble();
    pop_include_file('template', '--conf-lib-include--');
    return str;
}

function process_title_macro(macro_name: string, macro_args: string[]): string {
    return title;
}

function process_splash_screen_url_macro(macro_name: string, macro_args: string[]): string {
    return normalize_path(find_file_in_path('url', splash_screen_url));
}

function process_classes_macro(macro_name: string, macro_args: string[]): string {
    return "\n" + conf_lib_by_priority.map(
        (x) => "\t{\n\t\tname: '" +
                (x.name === undefined? "": x.name) +
                "',\n\t\tclasses: [\n\t\t\t" +
                x.class_list.join(",\n\t\t\t") +
                "\n\t\t]\n\t}").join(",\n") +
        "\n";
}


function process_textfile_macro(macro_name: string, macro_args: string[]): string {
    if (macro_args.length !== 1) {
        error_exit('textfile macro should have one argument');
    }
    const src_path = find_file_in_path('text', macro_args[0]);
    if (mode === 'incl') {
        console.log('textfile', src_path);
        return "";
    }
    var str: string = "";
    const fileLines: string[] = misc.readTextFileLines(src_path);
    for (const line of fileLines) {
        str += "\\n" + line.trimRight().replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }
    return str.slice(2);
}

function process_url_macro(macro_name: string, macro_args: string[]): string {
    if (macro_args.length !== 1) {
        error_exit('textfile macro should have one argument');
    }
    return find_file_in_path('url', macro_args[0]);
}

function process_macro(dtype: DTypeKey, line: string, fn: string, linenr: number, match: string[]): string|undefined {
    const macro_name = match[1];
    const macro_arg_str = match[2];
    // extract arguments
    const macro_args: string[] = macro_arg_str.split(/,+/);
    var macro_subst: string|undefined;

    if (macro_name === 'image') {
        macro_subst = process_image_macro(macro_name, macro_args);
    } else if (macro_name === 'data') {
        macro_subst = process_data_macro(macro_name, macro_args);
    } else if (macro_name === 'font') {
        macro_subst = process_font_macro(macro_name, macro_args);
    } else if (macro_name === 'buildinfo') {
        macro_subst = process_buildinfo_macro(macro_name, macro_args);
    } else if (macro_name === 'conflibPreamble') {
        macro_subst = process_conf_lib_preamble_macro(macro_name, macro_args);
    } else if (macro_name === 'title') {
        macro_subst = process_title_macro(macro_name, macro_args);
    } else if (macro_name === 'splashScreenUrl') {
        macro_subst = process_splash_screen_url_macro(macro_name, macro_args);
    } else if (macro_name === 'classes') {
        macro_subst = process_classes_macro(macro_name, macro_args);
    } else if (macro_name === 'textfile') {
        macro_subst = process_textfile_macro(macro_name, macro_args);
    } else if (macro_name === 'url') {
        macro_subst = process_url_macro(macro_name, macro_args);
    } else {
        error_exit(fn + ':' + String(linenr) + ": don't know (yet) how to handle macro '" + macro_name + "' in '" + line + "'");
    }

    if (macro_subst === undefined) {
        error_exit(fn + ':' + String(linenr) + ': empty subst');
    }
    return macro_subst;
}


function get_current_conf_lib_name(): string {
    return current_conf_lib === undefined || current_conf_lib.name === undefined?
           "": current_conf_lib.name;
}

function verify_current_conf_lib(conf_lib_name: string): void {
    let cblp_name: string|undefined = conf_lib_by_priority[0].name;

    if (cblp_name === undefined) {
        cblp_name = "";
    }
    if (cblp_name !== conf_lib_name) {
        error_exit('confLib names do not match');
    }
}


// replace 'var classes =' with 'var <CL>__<fn>__classes ='
// where <CL> is the current confLib (may be empty) and <fn> is the current
// source file name
function process_class_def(dtype: DTypeKey, line: string, fn: string): void {
    const conf_lib_name = get_current_conf_lib_name();
    verify_current_conf_lib(conf_lib_name);

    const mclass_name = conf_lib_name + '__' + stemname(fn, conf_lib_name) + '__classes';
    let mclass_def = 'var ' +  mclass_name + ' =';
    const match = line.match(/^\s*var[^=]*=(.*)$/);
    if (match === null) {
        return error_exit("process_class_def: match is null");
    }
    mclass_def = mclass_def + match[1] + "\n";

    section_print(dtype, mclass_def);
    conf_lib_by_priority[0].class_list.push(mclass_name);
}


/*
replace
   'var xxxConstants = { ... };'
 with
   'var <confLib1>__xxxConstants = { ... };'
 and then, at the end of the 'constantfile' section append
   'var xxxConstants = mergeCdlConstants(
       <confLib1>__xxxConstants,
       <confLib2>__xxxConstants,
       ...
    );'
 (ordered by confLib priority) to allow higher priority confLibs to
 overwrite constants defined in lower priority confLibs, such that the
 affect reaches back into the lower priority confLib. For example, if Core has

CellConstants = {
  width: 5
}

Cell: { position: { width: CellConstants.width } }

and Mon1 has
CellConstants = {
  width: 2
}

then setting CellConstants.width to 2 must occur before including Core::Cell

a constant definition is also identified as
var xxx = { // %%constantdef%%
*/
function process_constant_def(dtype: DTypeKey, line: string, fn: string): void {
    const conf_lib_name = get_current_conf_lib_name();
    verify_current_conf_lib(conf_lib_name);

    // neutralize processed %%constantdef%% by converting %% to %-
    const constdef_match = line.match(/^(.*\/\/.*)%%constantdef%%(.*)$/);
    if (constdef_match) {
        line = constdef_match[1] + '%-constantdef-%' +  constdef_match[2];
    }
    const match = line.match(/^\s*var\s+([a-zA-Z0-9_]+)\s*=(.*)$/);
    if (match === null || !match[1] || !match[2]) {
        return error_exit('constant_def: parse failure (' + line + ')');
    }

    const const_name = match[1];
    const mconst_name = conf_lib_name + '__' + const_name;
    const mconst_def = 'var ' + mconst_name + ' =' + match[2] + "\n";

    section_print(dtype, mconst_def);
    conf_lib_by_priority[0].constant.push({
        'name': const_name,
        'element': mconst_name
    });
}

/**
 * The pattern for macros; macros can occur more than once in a line
 */
const macro_re: RegExp = /%%([a-zA-Z0-9_]*):\(([^%()]*)\)%%/g;
/**
 * The pattern for includes. If there's an include, it consumes the whole line
 */
const include_re: RegExp = /^[^a-z]*%%[a-z]+%%:/;
/**
 * Pattern for class definition. This is a bit shaky in terms of JavaScript
 * syntax, but the author will simply have to stick with it.
 */
const varClassesRe: RegExp = /^\s*var\s+classes\s*=/; 
/**
 * Old-style pattern for class definition. This recognizes lines of the form
 * var <base_of_filename> = ... as identical to var classes = ... Set once per
 * file.
 */
var varStemnameRe: RegExp;

// Returns a string indicating the line type
// - 'class' when the line is var classes/stemname = ...
// - 'screen' when the line is var screenArea = ...
// - '' otherwise
function process_line(dtype: DTypeKey, rawLine: string, fn: string, linenr: number, basedir: string): string {
    const trimmedLine = rawLine.replace(/\r?\n$/, "");
    const line = trimmedLine.replace(macro_re, (... groups: string[]): string =>{
            const repl = process_macro(dtype, trimmedLine, fn, linenr, groups);
            if (repl === undefined) {
                return error_exit(`${fn}: ${linenr}: process_macro is undefined`);
            }
            return repl;
        });

    if (include_re.test(line)) {
        process_directive(line, fn, linenr, basedir);
    } else if (dtype === 'classfile' && (varClassesRe.test(line) || varStemnameRe.test(line))) {
        if (mode === 'js') {
            process_class_def(dtype, line, fn);
        }
        return 'class';
    } else if ((dtype == 'constantfile' &&
                /^\s*var\s+[a-zA-Z0-9_]+[cC]onstants\s*=/.test(line)) ||
                /\s*var\s+[a-zA-Z0-9_]+\s*=.*\/\/.*%%constantdef%%/.test(line)) {
        if (mode === 'js') {
            process_constant_def(dtype, line, fn);
        }
        return 'constant';
    } else {
        if (dtype === 'template' || mode === 'js') {
            section_print(dtype, line + "\n");
        }
        if (/^\s*var\s+screenArea\s*=/.test(line)) {
            return 'screen';
        }
        if (/^\s*var\s+test\s*=/.test(line)) {
            return 'test';
        }
    }
    return '';
}

function process_file(dtype: DTypeKey, filename: string, basedir: string): void {
    let class_found = false;
    let screen_area_found = false;
    let test_found = false;
    let constant_found = false;
    let linenr = 1;

    if (dtype === 'foreign') {
        add_resource_usage('foreign', filename);
        return;
    }

    let normalized_filename = normalize_path(filename);

    if (dtype === 'include' && fn_stack.length >= max_include_level) {
        return;
    }

    write_dep(normalized_filename);

    // annotate("process_file: type='" + dtype + "' filename='" + filename +
    //    "' (" + normalized_filename + ")")

    push_include_file(dtype, normalized_filename);

    if (!(normalized_filename in processed_files)) {
        const varStemnameForFileRe = new RegExp('^\s*var\s*' + stemname(normalized_filename, undefined) + '\s*=');
        processed_files[normalized_filename] = 1;

        try {
            let inputLines: string[]
            if (normalized_filename.endsWith(".cdl")) {
                const cdlText: string = misc.readTextFile(normalized_filename);
                cdlsyntax.setInputFileName(normalized_filename);
                cdlsyntax.parse(cdlText);
                if (cdlsyntax.errors.length !== 0) {
                    return error_exit("syntax errors in " + normalized_filename + "\n" + cdlsyntax.errors.join("\n"));
                }
                inputLines = cdlsyntax.conv;
            } else {
                inputLines = misc.readTextFileLines(normalized_filename);
            }
            for (const line of inputLines) {
                gen_filename_and_line_number(dtype, normalized_filename);
                varStemnameRe = varStemnameForFileRe;
                const line_type = process_line(dtype, line, normalized_filename, linenr, basedir);
                if (line_type === 'class') {
                    if (class_found) {
                        error_exit("two class definitions in " + normalized_filename);
                    }
                    class_found = true;
                } else if (line_type === 'screen') {
                    if (screen_area_found) {
                        error_exit("two screenAreas in " + normalized_filename);
                    }
                    screen_area_found = true;
                    nr_screen_area += 1;
                } else if (line_type === 'test') {
                    if (test_found) {
                        error_exit("two test definitions in " + normalized_filename);
                    }
                    test_found = true;
                    nr_test += 1;
                } else if (line_type === 'constant') {
                    constant_found = true;
                // if mode == 'incl' and (class_found or screen_area_found or test_found or constant_found):
                //     break # Stop scanning file for includes
                }
                linenr += 1;
            }
        } catch (e) {
            console.error("error reading file: " + normalized_filename + " from " + fn_stack[fn_stack.length - 2]);
            console.log(e.toString());
            sys.exit(1);
        }

        if (mode === 'html') {
            if ('html' in dtype_property[dtype]) {
                const html_handling = dtype_property[dtype].html;
                if (html_handling === 'script') {
                    section_print(dtype, '\t<script src="' + normalized_filename + '">');
                    section_print(dtype, '</script>\n');
                }
            }
        }

        if (dtype === 'classfile' && mode !== 'incl' && !screen_area_found && !class_found && !test_found) {
            console.error("WARNING: no screenArea, classes or test defined in " + normalized_filename);
        }
    }

    pop_include_file(dtype, normalized_filename);
}

const commandLineArguments: parseargs.CommandLineArgument[] = [
    { field: 'cdl_source', required: true }
];
const commandLineOptions1: {[arg: string]: parseargs.CommandLineOption} = {
    o: { alias: "out_file" },
    d: { alias: "dep_file" },
    t: { alias: "template" },
    m: { alias: "mode" },
    c: { alias: "libConf" }
};
const commandLineOptions2: {[arg: string]: parseargs.CommandLineOption} = {
    out_file: { required: true, argument: true },
    dep_file: { argument: true },
    dep_target: { argument: true },
    template: { argument: true, required: true },
    includedir: { argument: true },
    mode: { values: ['js', 'html', 'incl', 'make'], argument: true, required: true },
    langdir: { argument: true },
    cdldir: { argument: true },
    referencedir: { argument: true },
    sourcedir: { argument: true },
    libConf: { argument: true },
    buildInfoFile: { argument: true },
    resourceOutFile: { argument: true },
    resourceUseFile: { argument: true },
    "max-include-level": { argument: true, field: "max_include_level" },
    commonImageDir: { argument: true },
    commonDataDir: { argument: true },
    title: { argument: true },
    "splash-screen-url": { argument: true, field: "splash_screen_url" }
};

function main(): void {
    const args = parseargs.parse(sys.argv, commandLineArguments, commandLineOptions1, commandLineOptions2);

    set_reference_dir(args.referencedir);
    set_mode(args.mode);
    set_source_dir(args.sourcedir);
    append_root_path(args.langdir);
    append_root_path(args.cdldir);
    set_include_path(args.includedir);
    set_dep_file(args.dep_file);
    set_res_out_file(args.resourceOutFile);
    set_res_use_file(args.resourceUseFile);
    set_build_info_file(args.buildInfoFile);
    set_common_image_dir(args.commonImageDir);
    set_common_data_dir(args.commonDataDir);
    set_cdl_source(args.cdl_source);
    set_make_target(args.dep_target, args.out_file);
    set_max_include_level(args.max_include_level);
    set_out_file(args.out_file);
    set_lib_conf(args.libConf);
    set_title(args.title);
    set_splash_screen_url(args.splash_screen_url);
    
    process_file('template', args.template, os.path.dirname(args.template));
    write_resource_usage();

    fs.closeSync(out_file_handle);
    if (dep_file_handle !== undefined) {
        fs.closeSync(dep_file_handle);
    }

    if (mode === 'js' && out_file_name.endsWith(".comp.js.tmp") && nr_screen_area !== 1) {
        error_exit("no screenArea definition");
    }

    sys.exit(0);
}

main();

